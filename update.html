<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Location Analytics ‚Äî HR Metrics (All-in-one)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Leaflet (map) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- PapaParse (CSV parsing) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- html2canvas + jsPDF for PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- SheetJS for Excel export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root { --bg:#f6f7fb; --card:#fff; --muted:#6b7280; --accent:#2563eb; --warn:#f59e0b; --danger:#ef4444; --text:#111827; }
    body { font-family: system-ui, -apple-system, Arial, sans-serif; margin:0; background:var(--bg); color:var(--text); }
    header { padding:12px 16px; background:#0f1724; color:#fff; font-weight:700; }
    main { padding:12px 16px 24px; }
    .row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .panel { background:var(--card); border:1px solid #e5e7eb; border-radius:10px; padding:10px 12px; }
    .metrics { display:grid; grid-template-columns: repeat(2, minmax(220px, 1fr)); gap:8px; margin-top:8px; }
    @media (min-width:900px){ .metrics { grid-template-columns: repeat(4, minmax(220px, 1fr)); } }
    .metric { background:var(--card); border:1px solid #e5e7eb; border-radius:10px; padding:10px 12px; }
    .metric .k { font-size:12px; color:var(--muted); }
    .metric .v { font-size:18px; font-weight:700; margin-top:6px; word-break:break-word; }
    #map { height:520px; background:#eef2ff; border:1px solid #e5e7eb; border-radius:12px; margin-top:8px; }
    select, input[type="date"], input[type="number"], input[type="file"] { padding:6px 8px; border-radius:8px; border:1px solid #e5e7eb; background:#fff; }
    button { padding:6px 10px; border-radius:8px; border:1px solid #e5e7eb; background:#fff; cursor:pointer; }
    button.primary { background:var(--accent); color:#fff; border-color:var(--accent); }
    button.warn { background:var(--warn); color:#111827; border-color:var(--warn); }
    .legend { font-size:12px; color:var(--muted); }
    .pill { font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #e5e7eb; background:#f9fafb; }
    pre.app-details { font-size:12px; white-space:pre-wrap; margin:0; max-height:220px; overflow:auto; background:#fbfbfc; padding:8px; border-radius:6px; border:1px solid #eef2ff; }
    table.app-table { width:100%; border-collapse:collapse; font-size:13px; }
    table.app-table th, table.app-table td { border:1px solid #eef2ff; padding:6px; text-align:left; }
  </style>
</head>
<body>
  <header>üìç Location Analytics ‚Äî HR Metrics</header>
  <main>
    <!-- Controls -->
    <div class="row panel" style="justify-content:space-between;">
      <div class="row" style="gap:10px; align-items:center;">
        <input type="file" id="csvInput" accept=".csv" />
        <span class="legend">Required (any alias accepted): Latitude, Longitude, Activity/Speed, RecordedAt, TimeZone, AAID, LocationID, AppPackage/BundleID (optional), AppState</span>
      </div>
      <div class="row" style="gap:6px; align-items:center;">
        <label class="legend">Single Date</label>
        <input type="date" id="singleDate" />
        <label class="legend">Multiple Dates</label>
        <select id="multiDates" multiple size="3" style="min-width:180px;"></select>
        <button id="applyDates" class="primary">Apply</button>
        <button id="clearDates">Clear</button>
      </div>
    </div>

    <!-- Fake points + Exports -->
    <div class="row panel" style="justify-content:space-between; margin-top:8px;">
      <div class="row" style="gap:8px; align-items:center;">
        <span class="legend"><b>Fake Points:</b> add synthetic points near real ones (for demo/testing)</span>
        <label class="legend">Per Row</label>
        <input type="number" id="fakePerRow" min="0" max="5" step="1" value="1" />
        <button id="addFakes" class="warn">Add Fake Points</button>
        <button id="clearFakes">Clear Fake Points</button>
      </div>
      <div class="row" style="gap:6px; align-items:center;">
        <button id="downloadCsv">‚¨áÔ∏è Download Report (CSV)</button>
        <button id="downloadXlsx">‚¨áÔ∏è Download Report (Excel)</button>
        <button id="downloadPdf" class="primary">üì• Download PDF</button>
      </div>
    </div>

    <!-- Metrics -->
    <div class="section-title" style="margin-top:12px; font-weight:700;">Metrics</div>
    <div id="metrics" class="metrics panel" style="padding:12px;"></div>

    <!-- App details -->
    <div class="panel" id="appPanel" style="margin-top:8px; display:none;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="font-weight:700">App Location Counts (per app)</div>
        <div class="legend">Shows total locations + foreground/background split</div>
      </div>
      <div id="appDetails" style="margin-top:8px;"></div>
    </div>

    <!-- Map Filters -->
    <div class="section-title" style="margin-top:12px; font-weight:700;">Map</div>
    <div class="row panel" style="gap:10px; margin-top:8px;">
      <span class="legend"><b>Filters:</b></span>
      <select id="mapFilter">
        <option value="all">All</option>
        <option value="moving">Moving</option>
        <option value="visits">Visits</option>
        <option value="dup_all">All Duplicates</option>
        <option value="dup_moving">Moving Duplicates</option>
        <option value="dup_visits">Visit Duplicates</option>
        <option value="move_ha_50">Moving HA ‚â• 50m</option>
        <option value="visit_ha_30">Visits HA ‚â• 30m</option>
      </select>

      <span class="pill">Moving: <b style="color:var(--accent)">Blue</b></span>
      <span class="pill">Visits: <b style="color:var(--danger)">Red</b></span>
    </div>

    <div id="map" class="panel"></div>
  </main>

  <script>
    // ---------------- Utilities & Aliases ----------------
    const normKey = s => String(s||'').toLowerCase().replace(/[^a-z0-9]/g,'');
    function buildKeyMap(rows, metaFields) {
      const headers = Array.isArray(metaFields) && metaFields.length ? metaFields : (rows[0] ? Object.keys(rows[0]) : []);
      const map = {}; headers.forEach(h => map[normKey(h)] = h); return map;
    }
    function getField(row, keyMap, aliases, def = '') {
      for (const alias of aliases) {
        const nk = normKey(alias);
        if (keyMap[nk] !== undefined) { const v = row[keyMap[nk]]; if (v !== undefined && v !== null && v !== '') return v; }
      }
      for (const alias of aliases) {
        if (row.hasOwnProperty(alias)) { const v = row[alias]; if (v !== undefined && v !== null && v !== '') return v; }
      }
      return def;
    }
    function toNum(v) {
      if (v === null || v === undefined) return null;
      if (typeof v === 'number' && Number.isFinite(v)) return v;
      const s = String(v).trim(); if (!s) return null;
      const cleaned = s.replace(/[^0-9eE\.\-+]/g,''); const n = Number(cleaned);
      return Number.isFinite(n) ? n : null;
    }
    function parseDate(v){ if(!v && v!==0) return null; const s = String(v).replace('T',' ').replace('Z','').trim(); const d = new Date(s); return isNaN(d) ? null : d; }
    function ymd(d){ return d.getFullYear()+'-'+String(d.getMonth()+1).padStart(2,'0')+'-'+String(d.getDate()).padStart(2,'0'); }
    function classifyActivity(v, speed) {
      const s = String(v || '').toLowerCase();
      if (/^(stop|visit|stationary|idle)$/.test(s)) return 'visit';
      if (/(move|moving|drive|travel|walk|run|transit)/.test(s)) return 'moving';
      if (speed != null) return speed > 0.5 ? 'moving' : 'visit';
      return '';
    }
    function classifyNetwork(v) {
      const s = String(v || '').toLowerCase();
      if (!s) return null;
      if (/(wifi|wi[-\s]?fi|wlan)/.test(s)) return 'wifi';
      if (/(cell|mobile|3g|4g|5g|lte|edge|gprs|umts|hspa)/.test(s)) return 'cell';
      return null;
    }
    function classifyOnline(v) {
      const s = String(v || '').toLowerCase();
      if (!s) return null;
      if (/(^|[^a-z])online([^a-z]|$)|\b1\b|true|on/.test(s)) return 'online';
      if (/(^|[^a-z])offline([^a-z]|$)|\b0\b|false|off/.test(s)) return 'offline';
      return null;
    }
    function classifyAppState(v) {
      const s = String(v || '').toLowerCase();
      if (!s) return null;
      if (/(foreground|fg|front)/.test(s)) return 'foreground';
      if (/(background|bg|back)/.test(s)) return 'background';
      return null;
    }
    function classifyOS(v){
      const s = String(v || '').toLowerCase();
      if (!s) return null;
      if (/android/.test(s)) return 'android';
      if (/ios|iphone|ipad/.test(s)) return 'ios';
      return 'other';
    }
    function stats(arr){
      const c = arr.filter(x => x!=null && Number.isFinite(x));
      if (!c.length) return { max:0, min:0, avg:0, count:0, pct: t=>0 };
      const max = Math.max(...c), min = Math.min(...c), avg = c.reduce((a,b)=>a+b,0)/c.length;
      return { max, min, avg, count:c.length, pct: t => 100 * c.filter(x => x >= t).length / c.length };
    }

    // ---------------- Column aliases ----------------
    const A = {
      lat:       ['Latitude','latitude','lat','gpslat','y','latdeg','lat_','gps_lat'],
      lng:       ['Longitude','longitude','long','lng','gpslng','gpslon','x','lon','londeg','longtitude'],
      activity:  ['Activity','activity','Mode','mode','Motion','motion','MotionType','motionType','Status','isMoving'],
      speed:     ['Speed','speed','kmph','kmh','velocity','Velocity'],
      acc:       ['HorizontalAccuracy','horizontalAccuracy','Accuracy','accuracy','acc','hacc','hAccuracy','ha','horiz_acc'],
      recorded:  ['RecordedAt','recorded_at','Recorded At','Timestamp','Time','DateTime','Datetime','created_at','CreatedAt','EventTime','LogTime','recorded'],
      timezone:  ['TimeZone','timezone','tz','UTCOffset','Offset','Time Zone'],
      aaid:      ['AAID','aaid','ad_id','adid','idfa','IDFA','deviceid','device_id'],
      locationId:['LocationID','location_id','LocID','locid','RecordID','PointID','id','locationid'],
      network:   ['Network','network','Connection','Conn','ConnType','NetworkType','Bearer','Carrier'],
      online:    ['Online','online','Status','NetStatus','ConnectivityStatus','ConnectionStatus','IsOnline'],
      state:     ['AppState','app_state','State','state','App Mode','AppMode','ForegroundBackground','FG_BG','fgbg','appstate'],
      os:        ['OS','os','Platform','platform','DeviceOS','device_os'],
      app:       ['AppPackage','PackageName','BundleID','bundle','App','AppID','package','package_name','bundleid','app_package','appname']
    };

    // ---------------- Data state ----------------
    let ALL_ROWS = [];    // normalized rows (real + fake)
    let REAL_ROWS = [];   // only real rows
    let FILTERED_ROWS = []; // after date filter
    let headerMap = {};
    let FAKE_ROWS = [];
    let currentMapFilter = 'all';

    // ---------------- Map setup ----------------
    const map = L.map('map').setView([20,78],5);
    const base = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom:19, attribution:'¬© OpenStreetMap'
    }).addTo(map);
    const gMoving = L.featureGroup().addTo(map);
    const gVisits = L.featureGroup().addTo(map);
    const gDup   = L.featureGroup().addTo(map);

    function keyOf(r){
      return [
        (r.lat && r.lat.toFixed) ? r.lat.toFixed(6) : r.lat,
        (r.lng && r.lng.toFixed) ? r.lng.toFixed(6) : r.lng,
        String(r.recorded || '').trim(),
        String(r.timezone || '').trim(),
        String(r.aaid || '').trim()
      ].join('|');
    }

    // compute duplicates for a set of rows
    function computeDuplicates(rows){
      const seen = new Map();
      let dupTotal=0, dupMove=0, dupVisit=0;
      const dupKeysAll = new Set(), dupKeysMove = new Set(), dupKeysVisit = new Set();

      for (const r of rows) {
        const key = keyOf(r);
        const prev = seen.get(key);
        if (prev === undefined) {
          seen.set(key, String(r.locationId || ''));
        } else if (String(prev) !== String(r.locationId || '')) {
          dupTotal++;
          dupKeysAll.add(key);
          if (r.activity === 'moving') { dupMove++; dupKeysMove.add(key); }
          if (r.activity === 'visit')  { dupVisit++; dupKeysVisit.add(key); }
        }
      }
      return { dupTotal, dupMove, dupVisit, dupKeysAll, dupKeysMove, dupKeysVisit };
    }

    // filter predicate used both for metrics and map
    function wantPredicate(r, filterMode, dupMeta) {
      switch (filterMode) {
        case 'moving': return r.activity === 'moving';
        case 'visits': return r.activity === 'visit';
        case 'dup_all': return dupMeta.dupKeysAll.has(keyOf(r));
        case 'dup_moving': return dupMeta.dupKeysMove.has(keyOf(r));
        case 'dup_visits': return dupMeta.dupKeysVisit.has(keyOf(r));
        case 'move_ha_50': return r.activity === 'moving' && r.acc != null && r.acc >= 50;
        case 'visit_ha_30': return r.activity === 'visit' && r.acc != null && r.acc >= 30;
        default: return true;
      }
    }

    // refresh map using FILTERED_ROWS and currentMapFilter
    function refreshMap(rows, filterMode, dupMeta){
      gMoving.clearLayers(); gVisits.clearLayers(); gDup.clearLayers();
      const bounds = [];
      for (const r of rows) {
        if (!wantPredicate(r, filterMode, dupMeta)) continue;
        const isFake = r.__fake === true;
        const color = (r.activity === 'moving') ? '#2563eb' : '#ef4444';
        const markerOpts = { radius: isFake ? 4 : 5, color, fillColor: color, fillOpacity: isFake ? 0.5 : 0.85 };
        const m = L.circleMarker([r.lat, r.lng], markerOpts)
          .bindPopup(
            `<b>${r.activity || 'unknown'}${isFake ? ' (FAKE)' : ''}</b><br>Lat: ${r.lat}, Lon: ${r.lng}`
            + (r.speed != null ? `<br>Speed: ${r.speed} km/h` : '')
            + (r.acc != null ? `<br>HA: ${r.acc} m` : '')
            + (r.recorded ? `<br>Recorded: ${r.recorded}` : '')
            + (r.app ? `<br>App: ${r.app}` : '')
            + (r.aaid ? `<br>Device: ${r.aaid}` : '')
          );
        if (r.activity === 'moving') gMoving.addLayer(m); else gVisits.addLayer(m);
        bounds.push([r.lat, r.lng]);
      }
      // duplicate rings (for all filtered rows)
      rows.forEach(r => {
        const k = keyOf(r);
        if (dupMeta.dupKeysAll.has(k)) {
          L.circle([r.lat, r.lng], { radius: 20, color: 'var(--warn)', weight: 2, fill: false }).addTo(gDup);
        }
      });
      if (bounds.length) map.fitBounds(bounds, { padding: [30,30] });
    }

    // ---------------- HR Metrics calculation ----------------
    function calculateHRMetrics(rows){
      // rows should already be the set you want metrics for (e.g., date-filtered + map-filtered)
      const total   = rows.length;
      const osA     = rows.filter(r => r.os === 'android').length;
      const osI     = rows.filter(r => r.os === 'ios').length;
      const movingArr = rows.filter(r => r.activity==='moving');
      const visitArr  = rows.filter(r => r.activity==='visit');

      const dup = computeDuplicates(rows);

      const moveAcc = stats(movingArr.map(r => r.acc));
      const visitAcc= stats(visitArr.map(r => r.acc));
      const moveSpd = stats(movingArr.map(r => r.speed));

      const online  = rows.filter(r => r.online === 'online').length;
      const offline = rows.filter(r => r.online === 'offline').length;
      const wifi    = rows.filter(r => r.network === 'wifi').length;
      const cell    = rows.filter(r => r.network === 'cell').length;
      const fg      = rows.filter(r => r.appState === 'foreground').length;
      const bg      = rows.filter(r => r.appState === 'background').length;

      // Unique devices
      const uniqDevices = new Set(rows.map(r => String(r.aaid||'')).filter(s => s));
      const androidDevices = new Set(rows.filter(r => r.os==='android').map(r => String(r.aaid||'')).filter(s=>s));
      const iosDevices = new Set(rows.filter(r => r.os==='ios').map(r => String(r.aaid||'')).filter(s=>s));

      // Apps and per-app counts
      const appSet = new Set(rows.map(r => String(r.app||'')).filter(s => s));
      const appCounts = {}; // { appName: { total, fg, bg } }
      rows.forEach(r => {
        const a = r.app || null;
        if (!a) return;
        if (!appCounts[a]) appCounts[a] = { total:0, fg:0, bg:0 };
        appCounts[a].total++;
        if (r.appState === 'foreground') appCounts[a].fg++;
        if (r.appState === 'background') appCounts[a].bg++;
      });

      const res = {
        "OS: (Android or iOS)": `Android ${osA} ¬∑ iOS ${osI}`,
        "Total Location Points": total,
        "Total Moving Points": movingArr.length,
        "Total Visits Points": visitArr.length,
        "Total Duplicate Points": dup.dupTotal,
        "Total Moving Duplicate Points": dup.dupMove,
        "Total Vist Duplicate Points": dup.dupVisit,
        "Max Moving Horizontal Accuracy": moveAcc.max.toFixed(1),
        "Min Moving Horizontal Accuracy": moveAcc.min.toFixed(1),
        "Average Moving Horizontal Accuracy": moveAcc.avg.toFixed(1),
        "Moving Horizontal Accuracy >= 50 Meters %": moveAcc.pct(50).toFixed(1) + '%',
        "Max Visits Horizontal Accuracy": visitAcc.max.toFixed(1),
        "Min Visits Horizontal Accuracy": visitAcc.min.toFixed(1),
        "Average Visits Horizontal Accuracy": visitAcc.avg.toFixed(1),
        "Visits Horizontal Accuracy >= 30 Meters %": visitAcc.pct(30).toFixed(1) + '%',
        "Total Online Points": online,
        "Total Offline Points": offline,
        "Total WiFi Points": wifi,
        "Total Cellular Points": cell,
        "Total Foreground Points": fg,
        "Total Background Points": bg,
        "Max Moving Speed": moveSpd.max.toFixed(1),
        "Min Moving Speed": moveSpd.min.toFixed(1),
        "Average Moving Speed": moveSpd.avg.toFixed(1),
        "Moving Speed >= 100 Km/h %": moveSpd.pct(100).toFixed(1) + '%',
        // NEW device/app metrics
        "Total Unique Devices": uniqDevices.size,
        "Total Android Unique Devices": androidDevices.size,
        "Total iOS Unique Devices": iosDevices.size,
        "Total Apps": appSet.size,
        "List of Apps": [...appSet].join(', ') || '‚Äî',
        "App Details (raw)": appCounts
      };
      return { metrics: res, dupMeta: dup, appCounts };
    }

    // render metrics to the page; rows passed in should be the dataset to report on
    function renderMetrics(rows, filterMode){
      const { metrics, dupMeta, appCounts } = calculateHRMetrics(rows);
      const entries = Object.entries(metrics);
      const container = document.getElementById('metrics');
      const html = entries.map(([k,v]) => {
        // App Details handled separately
        if (k === 'App Details (raw)') return '';
        return `
          <div class="metric">
            <div class="k">${k}</div>
            <div class="v">${(typeof v === 'number' || typeof v === 'string') ? v : JSON.stringify(v)}</div>
          </div>
        `;
      }).join('');
      container.innerHTML = html;

      // show app panel with table
      const appPanel = document.getElementById('appPanel');
      const appDetails = document.getElementById('appDetails');
      if (appCounts && Object.keys(appCounts).length) {
        appPanel.style.display = 'block';
        // build table
        let rowsHtml = `<table class="app-table"><thead><tr><th>App (Package/Bundle)</th><th>Total</th><th>Foreground</th><th>Background</th></tr></thead><tbody>`;
        Object.entries(appCounts).sort((a,b)=>b[1].total - a[1].total).forEach(([app,counts])=>{
          rowsHtml += `<tr><td style="max-width:400px;word-break:break-word">${app}</td><td>${counts.total}</td><td>${counts.fg}</td><td>${counts.bg}</td></tr>`;
        });
        rowsHtml += `</tbody></table>`;
        appDetails.innerHTML = rowsHtml;
      } else {
        appPanel.style.display = 'none';
        appDetails.innerHTML = '';
      }

      return dupMeta;
    }

    // ---------------- Per-day report builder ----------------
    function buildDailyReport(rows){
      const byDay = new Map();
      for (const r of rows) {
        const d = parseDate(r.recorded); if (!d) continue;
        const key = ymd(d);
        if (!byDay.has(key)) byDay.set(key, []);
        byDay.get(key).push(r);
      }
      const lines = [];
      const header = [
        'Date',
        'OS: (Android or iOS)',
        'Total Location Points',
        'Total Moving Points',
        'Total Visits Points',
        'Total Duplicate Points',
        'Total Moving Duplicate Points',
        'Total Vist Duplicate Points',
        'Max Moving Horizontal Accuracy',
        'Min Moving Horizontal Accuracy',
        'Average Moving Horizontal Accuracy',
        'Moving Horizontal Accuracy >= 50 Meters %',
        'Max Visits Horizontal Accuracy',
        'Min Visits Horizontal Accuracy',
        'Average Visits Horizontal Accuracy',
        'Visits Horizontal Accuracy >= 30 Meters %',
        'Total Online Points',
        'Total Offline Points',
        'Total WiFi Points',
        'Total Cellular Points',
        'Total Foreground Points',
        'Total Background Points',
        'Max Moving Speed',
        'Min Moving Speed',
        'Average Moving Speed',
        'Moving Speed >= 100 Km/h %',
        'Total Unique Devices',
        'Total Android Unique Devices',
        'Total iOS Unique Devices',
        'Total Apps',
        'List of Apps',
        'App Details (JSON)'
      ];
      lines.push(header);
      for (const [day, arr] of [...byDay.entries()].sort((a,b)=>a[0].localeCompare(b[0]))) {
        const { metrics } = calculateHRMetrics(arr);
        lines.push([
          day,
          metrics['OS: (Android or iOS)'],
          metrics['Total Location Points'],
          metrics['Total Moving Points'],
          metrics['Total Visits Points'],
          metrics['Total Duplicate Points'],
          metrics['Total Moving Duplicate Points'],
          metrics['Total Vist Duplicate Points'],
          metrics['Max Moving Horizontal Accuracy'],
          metrics['Min Moving Horizontal Accuracy'],
          metrics['Average Moving Horizontal Accuracy'],
          metrics['Moving Horizontal Accuracy >= 50 Meters %'],
          metrics['Max Visits Horizontal Accuracy'],
          metrics['Min Visits Horizontal Accuracy'],
          metrics['Average Visits Horizontal Accuracy'],
          metrics['Visits Horizontal Accuracy >= 30 Meters %'],
          metrics['Total Online Points'],
          metrics['Total Offline Points'],
          metrics['Total WiFi Points'],
          metrics['Total Cellular Points'],
          metrics['Total Foreground Points'],
          metrics['Total Background Points'],
          metrics['Max Moving Speed'],
          metrics['Min Moving Speed'],
          metrics['Average Moving Speed'],
          metrics['Moving Speed >= 100 Km/h %'],
          metrics['Total Unique Devices'],
          metrics['Total Android Unique Devices'],
          metrics['Total iOS Unique Devices'],
          metrics['Total Apps'],
          metrics['List of Apps'],
          JSON.stringify(metrics['App Details (raw)'] || {})
        ]);
      }
      if (rows.length) {
        const { metrics } = calculateHRMetrics(rows);
        lines.push([
          'OVERALL',
          metrics['OS: (Android or iOS)'],
          metrics['Total Location Points'],
          metrics['Total Moving Points'],
          metrics['Total Visits Points'],
          metrics['Total Duplicate Points'],
          metrics['Total Moving Duplicate Points'],
          metrics['Total Vist Duplicate Points'],
          metrics['Max Moving Horizontal Accuracy'],
          metrics['Min Moving Horizontal Accuracy'],
          metrics['Average Moving Horizontal Accuracy'],
          metrics['Moving Horizontal Accuracy >= 50 Meters %'],
          metrics['Max Visits Horizontal Accuracy'],
          metrics['Min Visits Horizontal Accuracy'],
          metrics['Average Visits Horizontal Accuracy'],
          metrics['Visits Horizontal Accuracy >= 30 Meters %'],
          metrics['Total Online Points'],
          metrics['Total Offline Points'],
          metrics['Total WiFi Points'],
          metrics['Total Cellular Points'],
          metrics['Total Foreground Points'],
          metrics['Total Background Points'],
          metrics['Max Moving Speed'],
          metrics['Min Moving Speed'],
          metrics['Average Moving Speed'],
          metrics['Moving Speed >= 100 Km/h %'],
          metrics['Total Unique Devices'],
          metrics['Total Android Unique Devices'],
          metrics['Total iOS Unique Devices'],
          metrics['Total Apps'],
          metrics['List of Apps'],
          JSON.stringify(metrics['App Details (raw)'] || {})
        ]);
      }
      return lines;
    }

    function downloadCSV(rows){
      const data = buildDailyReport(rows);
      const csv = Papa.unparse(data);
      const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'HR_Location_Analytics_Report.csv';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function downloadXLSX(rows){
      const data = buildDailyReport(rows);
      const ws = XLSX.utils.aoa_to_sheet(data);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'Report');
      XLSX.writeFile(wb, 'HR_Location_Analytics_Report.xlsx');
    }

    // ---------------- Date selectors ----------------
    function rebuildDateList(rows){
      const s = new Set();
      rows.forEach(r => { const d = parseDate(r.recorded); if (d) s.add(ymd(d)); });
      const list = [...s].sort();
      const sel = document.getElementById('multiDates');
      sel.innerHTML = list.map(d => `<option value="${d}">${d}</option>`).join('');
    }
    function applyDateFilter(){
      const single = document.getElementById('singleDate').value;
      const multi = Array.from(document.getElementById('multiDates').selectedOptions).map(o => o.value);
      const wanted = new Set([...multi, ...(single ? [single] : [])]);
      if (wanted.size === 0) { FILTERED_ROWS = ALL_ROWS.slice(); return; }
      FILTERED_ROWS = ALL_ROWS.filter(r => {
        const d = parseDate(r.recorded); return d ? wanted.has(ymd(d)) : false;
      });
    }

    // ---------------- CSV handling ----------------
    document.getElementById('csvInput').addEventListener('change', e => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      Papa.parse(file, {
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true,
        complete: res => {
          const rowsRaw = res.data || [];
          headerMap = buildKeyMap(rowsRaw, res.meta && res.meta.fields);
          // Normalize rows
          const normalized = rowsRaw.map(r => {
            const lat = toNum(getField(r, headerMap, A.lat));
            const lng = toNum(getField(r, headerMap, A.lng));
            const speed = toNum(getField(r, headerMap, A.speed));
            const acc = toNum(getField(r, headerMap, A.acc));
            const activity = classifyActivity(getField(r, headerMap, A.activity, ''), speed);
            const recorded = getField(r, headerMap, A.recorded, '');
            const timezone = getField(r, headerMap, A.timezone, '');
            const aaid = getField(r, headerMap, A.aaid, '');
            const locationId = getField(r, headerMap, A.locationId, '');
            const network = classifyNetwork(getField(r, headerMap, A.network, ''));
            const online = classifyOnline(getField(r, headerMap, A.online, ''));
            const appState = classifyAppState(getField(r, headerMap, A.state, ''));
            const os = classifyOS(getField(r, headerMap, A.os, ''));
            const app = getField(r, headerMap, A.app, '');
            return { lat, lng, speed, acc, activity, recorded, timezone, aaid, locationId, network, online, appState, os, app, __fake:false };
          }).filter(r => r.lat != null && r.lng != null);

          REAL_ROWS = normalized;
          FAKE_ROWS = [];
          ALL_ROWS = [...REAL_ROWS];
          FILTERED_ROWS = ALL_ROWS.slice();

          rebuildDateList(ALL_ROWS);
          currentMapFilter = document.getElementById('mapFilter').value;
          // compute dupMeta for filtered rows
          const dupMeta = computeDuplicates(FILTERED_ROWS);
          // For metrics, apply the current map filter as well (so metrics reflect what map shows)
          const rowsForMetrics = FILTERED_ROWS.filter(r => wantPredicate(r, currentMapFilter, dupMeta));
          renderMetrics(rowsForMetrics, currentMapFilter);
          refreshMap(FILTERED_ROWS, currentMapFilter, dupMeta);
        },
        error: err => {
          alert('CSV parse error: ' + err.message);
          console.error(err);
        }
      });
    });

    // ---------------- Fake points (same algorithm as before) ----------------
    function jitter(val, meters){
      const degLat = meters / 111111;
      return val + (Math.random() - 0.5) * 2 * degLat;
    }
    function jitterLng(lng, lat, meters){
      const mPerDeg = 111111 * Math.cos((lat||0) * Math.PI/180);
      const degLng = meters / (mPerDeg || 1);
      return lng + (Math.random() - 0.5) * 2 * degLng;
    }
    function createFakeFromRow(r, idx){
      const isMoving = (idx % 2 === 0);
      const recordedDate = parseDate(r.recorded) || new Date();
      const deltaMin = 1 + Math.floor(Math.random()*6);
      const when = new Date(recordedDate.getTime() + (isMoving ? deltaMin : -deltaMin) * 60000);
      const lat2 = jitter(r.lat, 15 + Math.random()*25);
      const lng2 = jitterLng(r.lng, r.lat, 15 + Math.random()*25);
      const acc = isMoving ? (20 + Math.random()*60) : (10 + Math.random()*50);
      const speed = isMoving ? (5 + Math.random()*90) : 0;
      const activity = isMoving ? 'moving' : 'visit';
      return {
        lat: lat2, lng: lng2, speed, acc, activity,
        recorded: when.toISOString().slice(0,19).replace('T',' '),
        timezone: r.timezone, aaid: r.aaid,
        locationId: `FAKE_${r.locationId}_${Date.now()}_${Math.floor(Math.random()*1000)}`,
        network: r.network, online: r.online, appState: r.appState, os: r.os, app: r.app,
        __fake: true
      };
    }
    function addFakePoints(perRow){
      if (!REAL_ROWS.length) { alert('Upload a CSV first.'); return; }
      perRow = Math.max(0, Math.min(5, Number(perRow)||0));
      const news = [];
      REAL_ROWS.forEach(r => {
        for (let i=0;i<perRow;i++) news.push(createFakeFromRow(r,i));
      });
      FAKE_ROWS = news;
      ALL_ROWS = [...REAL_ROWS, ...FAKE_ROWS];
      applyDateFilter();
      const dupMeta = computeDuplicates(FILTERED_ROWS);
      const rowsForMetrics = FILTERED_ROWS.filter(r => wantPredicate(r, currentMapFilter, dupMeta));
      renderMetrics(rowsForMetrics, currentMapFilter);
      refreshMap(FILTERED_ROWS, currentMapFilter, dupMeta);
      rebuildDateList(ALL_ROWS);
    }
    function clearFakePoints(){
      FAKE_ROWS = [];
      ALL_ROWS = [...REAL_ROWS];
      applyDateFilter();
      const dupMeta = computeDuplicates(FILTERED_ROWS);
      const rowsForMetrics = FILTERED_ROWS.filter(r => wantPredicate(r, currentMapFilter, dupMeta));
      renderMetrics(rowsForMetrics, currentMapFilter);
      refreshMap(FILTERED_ROWS, currentMapFilter, dupMeta);
      rebuildDateList(ALL_ROWS);
    }

    // ---------------- Events ----------------
    document.getElementById('applyDates').addEventListener('click', () => {
      applyDateFilter();
      const dupMeta = computeDuplicates(FILTERED_ROWS);
      const rowsForMetrics = FILTERED_ROWS.filter(r => wantPredicate(r, currentMapFilter, dupMeta));
      renderMetrics(rowsForMetrics, currentMapFilter);
      refreshMap(FILTERED_ROWS, currentMapFilter, dupMeta);
    });
    document.getElementById('clearDates').addEventListener('click', () => {
      document.getElementById('singleDate').value = '';
      Array.from(document.getElementById('multiDates').options).forEach(o => o.selected = false);
      FILTERED_ROWS = ALL_ROWS.slice();
      const dupMeta = computeDuplicates(FILTERED_ROWS);
      const rowsForMetrics = FILTERED_ROWS.filter(r => wantPredicate(r, currentMapFilter, dupMeta));
      renderMetrics(rowsForMetrics, currentMapFilter);
      refreshMap(FILTERED_ROWS, currentMapFilter, dupMeta);
    });

    document.getElementById('mapFilter').addEventListener('change', e => {
      currentMapFilter = e.target.value;
      const dupMeta = computeDuplicates(FILTERED_ROWS);
      const rowsForMetrics = FILTERED_ROWS.filter(r => wantPredicate(r, currentMapFilter, dupMeta));
      renderMetrics(rowsForMetrics, currentMapFilter);
      refreshMap(FILTERED_ROWS, currentMapFilter, dupMeta);
    });

    document.getElementById('addFakes').addEventListener('click', () => {
      const n = document.getElementById('fakePerRow').value;
      addFakePoints(n);
    });
    document.getElementById('clearFakes').addEventListener('click', clearFakePoints);

    document.getElementById('downloadCsv').addEventListener('click', () => {
      const rows = FILTERED_ROWS.length ? FILTERED_ROWS : ALL_ROWS;
      if (!rows.length) { alert('No data to export.'); return; }
      downloadCSV(rows);
    });
    document.getElementById('downloadXlsx').addEventListener('click', () => {
      const rows = FILTERED_ROWS.length ? FILTERED_ROWS : ALL_ROWS;
      if (!rows.length) { alert('No data to export.'); return; }
      downloadXLSX(rows);
    });

    // ---------------- PDF Export ----------------
    async function waitForMapRender() { await new Promise(r => setTimeout(r, 350)); }

    document.getElementById('downloadPdf').addEventListener('click', async () => {
      const rows = FILTERED_ROWS.length ? FILTERED_ROWS : ALL_ROWS;
      if (!rows.length) { alert('Please upload a CSV first.'); return; }

      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF('p','mm','a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const left = 12;
      let y = 14;

      pdf.setFont('helvetica','bold');
      pdf.setFontSize(14);
      pdf.text('HR Location Analytics Report', left, y); y += 8;

      const now = new Date();
      pdf.setFont('helvetica','normal'); pdf.setFontSize(10);
      pdf.text(`Generated: ${now.toLocaleString()}`, left, y); y += 6;

      const single = document.getElementById('singleDate').value || '‚Äî';
      const multi = Array.from(document.getElementById('multiDates').selectedOptions).map(o=>o.value);
      const mapFilter = document.getElementById('mapFilter').value;
      const fakeCount = FAKE_ROWS.length;
      pdf.text(`Single Date: ${single}`, left, y); y += 5;
      pdf.text(`Multiple Dates: ${multi.length ? multi.join(', ') : '‚Äî'}`, left, y); y += 5;
      pdf.text(`Map Filter: ${mapFilter}`, left, y); y += 5;
      pdf.text(`Fake Points: ${fakeCount}`, left, y); y += 8;

      const dupMeta = computeDuplicates(rows);
      const rowsForMetrics = rows.filter(r => wantPredicate(r, mapFilter, dupMeta));
      const { metrics } = calculateHRMetrics(rowsForMetrics);
      pdf.setFont('helvetica','bold'); pdf.setFontSize(12);
      pdf.text('Metrics', left, y); y += 6;
      pdf.setFont('helvetica','normal'); pdf.setFontSize(11);

      for (const [k, v] of Object.entries(metrics)) {
        if (k === 'App Details (raw)') continue;
        const line = `${k}: ${v}`;
        const split = pdf.splitTextToSize(line, pageWidth - left*2);
        if (y + split.length*6 > 280) { pdf.addPage(); y = 14; }
        pdf.text(split, left, y);
        y += split.length*6;
      }

      // Map snapshot on a new page
      pdf.addPage();
      await waitForMapRender();
      const mapEl = document.getElementById('map');
      const canvas = await html2canvas(mapEl, { scale: 2, useCORS: true });
      const imgData = canvas.toDataURL('image/png');
      const w = pageWidth - 20;
      const h = canvas.height * (w / canvas.width);
      pdf.setFont('helvetica','bold'); pdf.setFontSize(12);
      pdf.text('Map (current view & filter)', 10, 12);
      pdf.addImage(imgData, 'PNG', 10, 16, w, h);

      pdf.save('HR_Location_Analytics.pdf');
    });
  </script>
</body>
</html>
